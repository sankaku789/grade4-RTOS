#import "config.typ":*
#import "@preview/codelst:2.0.2":*
#import "@preview/zebraw:0.5.5":*

//#include "title.typ" //学校指定の表紙の場合は，ここをコメントアウトして別途マージしてください。

#show: ss-setup.with()

#titlePage()[
  #align(center)[
    #Huge()[令和6年度] 

    #Huge()[情報科学・工学実験II] 

    #large()[～数値計算誤差～]
  ]

  #v(90pt)

  #align(center)[
    #large()[提出日] 

    #large()[2025 年01 月 21日（火）] 

    #v(10pt)

    #large()[報告者] 

    #large()[3年5組 3番 池田光聡]
  ]
]

= 実験の目的

浮動小数点を用いて10進数を表すとき, 有限桁で表現できない数値が存在する。
有限桁で表せない数値を計算に用いると, 実際に手計算した場合と比較して得られる結果と違う場合があり, その誤差が蓄積されることにより理論上得られる計算結果と計算機の結果が異なる場合がある。
本実験では, 初歩的な例題によりこのとこを確かめ, 解決法を探る。

= 原理 <sec:theory>

== 実数の2進数表現 <subsec:binary>

任意の実数をrとした場合, rを2進数に変換するときは, rを2倍していき, その値が1以上になったら1.1未満だったら0を書き, 0を書き, 0になるまで繰り返し, 変換していく。
例えば, 10進数で0.375を変換するときは以下の通りになる。
$ 0.375 times 2 &= 0.5 arrow.r 0 #linebreak()
  0.75 times 2 &= 1.5 arrow.r 1 #linebreak()
  0.5 times 2 &= 1.0 arrow.r 1 #linebreak()
  arrow.r (0.375)_10 &= (0.011)_2 #linebreak()
$

== 実数の浮動小数点表記

以下に，浮動小数点の表現形式を示す。
#parbreak()
#align(center)[
  #figure(
    image("example/img/IEEE754.png"),
    caption: [浮動小数点の表現形式],
  )<fig:IEEE754>
]
#parbreak()
計算機内では, 浮動小数点は@fig:IEEE754 のように表現される。
実数をN, 符号部をB, 指数部をE, 仮数部をFとするとNは以下のように表される。
$
  N &= -1^E times F times 2^B
$

浮動小数点を表す規格の1つとしてIEEE754があり, 浮動小数点の形式を規定している。
IEEE754には以下の種類がある。

- *単精度型*
  - 符号部1bit, 指数部8bit, 仮数部23bitの計32bit(4byte)で構成される。
  - C言語でいうfloat型に相当する。
- *倍精度型*
  - 符号部1bit, 指数部11bit, 仮数部52bitの計64bit(8byte)で構成される。
  - C言語でいうdouble型に相当する。

上記の仕様から, 浮動小数点は有限桁で表されることがわかる。
この有限桁であふれてしまう実数を2進数で表現する場合, あるいは2進数で有限桁で表せられない0.1のような実数の場合には, 浮動小数点で表現すると誤差を含むことになる。

= 実験器具
本実験では以下の環境を用いて実験を行った。

- 計算機の仕様
  - CPU: AMD Ryzen7 PRO 7840U(3.3GHz, 8コア)
  - Byte Order Type: リトルエンディアン
  - Memory: 16GB
  - OS: Windows11 24H2
- Cプログラムの実行環境
  - System: Windows Subsystem for Linux 2(Ubuntu 22.04.5 LTS)
  - Compiler: gcc version 11.4.0
  - Editor: Visual Studio Code

なお, これ以降gcc環境においては, float型は32bit, double型は64bitとする。

= 実験方法

== EX1
#link("https://github.com/doi-shigeo/TmNCT-ErrorsInComputation/blob/main/SimpleAddition.c")[github]を参照し，
0.5と0.7をそれぞれ倍精度浮動小数点型で表現した場合, どのように表されるかを確認した。

== EX2
EX1のプログラムを改良し, 0に初期化したdouble型の変数に対し, 0.7と0.5についてそれぞれ1000回加算し, その値が700と一致するかを確かめるプログラムを作成した。
また, その実行結果を記した。

= 実験結果

== EX1
以下に, 0.5と0.7にて実行したソースコードとその実行結果を示す。
なお, 実行結果は100行以上にわたるため, 最初の11行と最後の11行を示す。

#figure(
  sourcefile(read("example/src/exp2-1.c"), lang: "c"),
  caption: [ソースコードexp1-1(0.5の場合)],
  kind: "list"
)<src:ex1-1>

#figure(
  sourcefile(read("example/src/exp2-2.c"), lang: "c"),
  caption: [ソースコードexp1-2(0.7の場合)],
  kind: "list"
)<src:ex1-2>

#figure(
  sourcefile(read("example/result/exp2-1.txt")),
  caption: [0.5の場合の実行結果],
  kind: "list"
)<rlt:ex1-1>

#figure(
  sourcefile(read("example/result/exp2-2.txt")),
  caption: [0.7の場合の実行結果],
  kind: "list"
)<rlt:ex1-2>

@src:ex1-1, @src:ex1-2 のプログラムでは, 共用体DLを作成し, double型メンバの0.0に0.5または0.7を100回(TIME定数の値分)足しており, 計算経過と最終的に理論値と一致するかを標準出力している。
また, 計算経過での値を標準出力する際は, 小数点以下20桁で出力している他, 共用体のlong int型メンバを用いて浮動小数点表示(16進数での表示)をしている。

== EX2
以下に, 0.5と0.7にて実行したソースコードとその実行結果を示す。なお, 実行結果は100行以上にわたるため, 最初の20行と最後の20行を示す。

#figure(
  sourcefile(read("example/src/exp3.c"), lang: "c"),
  caption: [ソースコードexp2-1(0.5の場合)],
  kind: "list"
)<src:ex2-1>

#figure(
  sourcefile(read("example/src/exp4.c"), lang: "c"),
  caption: [ソースコードexp2-2(0.7の場合)],
  kind: "list"
)<src:ex2-2>

#figure(
  sourcefile(read("example/result/exp4.txt")),
  caption: [0.5の場合の実行結果],
  kind: "list"
)<rlt:ex2-1>

#figure(
  sourcefile(read("example/result/exp3.txt")),
  caption: [0.7の場合の実行結果],
  kind: "list"
)<rlt:ex2-2>

@src:ex1-1, @src:ex1-2 のプログラムでは, 共用体を作成し, double型メンバの0.0に0.5または0.7を1000回(TIME定数の値分)足しており, 計算経過と最終的に理論値と一致するかを標準出力している。また, 計算経過での値を標準出力する際は, 小数点以下20桁で出力している他, 共用体のlong int型メンバを用いて浮動小数点表示(16進数での表示)をしている。

= 考察
@src:ex1-1 を実行した際, 10進数の0.5は16進数(浮動小数点表記)では0x3fe0000000000000となり, 符号部は0, 仮数部は0, 指数部は1となった。
一方, @src:ex1-2 を実行した際, 10進数の0.7は16進数では0x3fe6666666666,となり, 符号部が0, 仮数部は6710883, 指数部は1となった。
しかし, 0x3fe6666666666666を実数として表示すると, 0.69999999999999995559...と近似値で表現され誤差が生じた。\

次に, @src:ex2-1 の実行結果では, 0.0から0.5ずつ1000回加算をした。
その際, 計算過程を16進表記すると, それぞれ0x0, 0x3fe0000000000000, 0x3ff0000000000000, 0x3ff8000000000000, ..., 0x407f300000000000, 0x407f380000000000, 0x407f400000000000となった。
また, 実数に変換するとそれぞれ0, 0.5, 1.0, 1.5, ..., 499.0, 499.5, 500.0となり, 理論値である500と一致した。
一方, @src:ex2-2 にて0.0から0.7ずつ1000回加算し, その際の計算過程を16進表記すると, それぞれ0x0, 0x3fe6666666666666, 0x3ff6666666666666, 0x4000cccccccccccc, ..., 0x4085d4cccccccd04, 0x4085da666666669e, 0x4085e00000000038となった。
これを実数に変換するとそれぞれ0, 0.69999999999999995559, 1.39999999999999991118, 2.09999999999999964473, ..., 698.60000000000627551344, 699.30000000000632098818, 700.00000000000636646291となり, 理論値である0, 0.7, 1.4, 2.1, ..., 698.6, 699.3, 700.0と一致せず誤差が発生した。\

第@sec:theory にて説明した通り, 2進小数表現では$2^n$の組み合わせで表現できない場合は無限桁になる。
また, 浮動小数点はその仕様上2進小数表現にて有限桁で表せない場合は, 誤差が生じる。実数の0.5と0.7をそれぞれ@subsec:binary に説明した手順にそって, 2進小数表現に変換すると, 
それぞれ0.1と0.1011001...となり, 0.7は無限桁(循環小数)となる。
また, 2進小数表現から浮動小数点表記に変換すると, それぞれ0x3fe0000000000000と0x3fe66666666666666になり, 再び実数に変換すると0.5と0.69999999999999995559になる。
通常誤差が生じた数値を用いて計算をしても誤差はなくならない。これにより, 0.7で加算すると誤差が生じ蓄積されるため, 最終結果も誤差が生じ, 理論値と一致しない事象が発生したと言える。

= まとめ
浮動小数点を用いて10進数を表すとき, 有限桁で表現できない数値が存在し, 誤差が生じること確かめることができた。また, その誤差が蓄積されることにより理論上得られる計算結果と計算機の結果が異なる場合があることを確かめることができた。

= 感想
ゲーム開発などにおいても, 浮動小数点の誤差による動作の変化は重要となるため, 小数を用いた演算を行う場合には常に注意が必要だ。