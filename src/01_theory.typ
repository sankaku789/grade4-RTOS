= 原理

#include "research.typ"

== 使用するRTOSとその要素技術

本実験では，@sec:rtos-types[]項にて示したTOPPERSプロジェクトの一つである，TOPPERS/ASP（TOPPERS/Advanced Standard Profile）カーネルを使用する．このカーネルはμITRON4.0仕様に準拠しており，割込み処理モデルの標準化や，コンフィグレーションの見直し，コンポーネント開発への対応などが行われている．μITRON4.0仕様#footnote[この規定は東京大学の坂村 健，及び，高田 広章らによって作成された．]とは，組込みシステム用リアルタイムOSとその仕様を定めた規定である．特徴として，多数の組込み用プロセッサに対応しており，自由に実装できるオープンな仕様であることが挙げられる．

次に，TOPPERS/ASPカーネルの主要な要素技術について説明する．

=== タスク

「タスク」(または，プロセス)は，プログラムの実行単位であり，オペレーティングシステムにおける基本概念である．1つのタスクは逐次実行され，異なるタスクのプログラムはスケジューリングによって並列実行される．タスクのうち，後述するサービスコール(SVC)を呼び出すタスクを「自タスク」という．

次に，タスクが実行される環境のことを「コンテキスト」と呼ぶ．コンテキストは，プロセッサの動作モード，レジスタ，スタック空間から構成される．また，コンテキストのうち，OSが管理し，スケジューラの想定しているタイミングで実行されるコンテキストは「タスクコンテキスト」という．ここで，タスクコンテキストは，スケジューラの想定しているタイミングで実行されるため，OSにとっては同期的と言える．一方，割込み処理ルーチンなどOSの想定外のタイミングで実行されるコンテキストは「非タスクコンテキスト」と呼ばれる．

#figure(
  image("fig/state.pdf", width: 65%),
  caption: [タスクの状態遷移図]
)<fig:task-state>

次に，タスクの状態について説明する．μITRON4.0では，広義的に5つの状態が存在する．

1. *実行状態（RUNNING）*  \
  @fig:task-state における[1]である．CPUリソースを確保し，そのタスクがプログラムを実行中している状態であり，そのタスク(プログラム)を実行している状態である．

2. *実行可能状態（READY）* \
  @fig:task-state における[2]である．CPUリソースを確保していないが，実行可能な状態であり，スケジューラによって選択されるのを待っている状態である．

3. *待ち状態（WAITING）* \
  @fig:task-state における[3][4][5]である．イベントの発生や，リソースの解放などを待っている状態であり，その条件が満たされるまで実行できない状態である．

4. *休止状態（DORMANT）* \
  @fig:task-state における[6]である．タスクがまだ起動されていない，言い換えると，実行可能状態になる前の状態である．

5. *未登録状態（NON-EXISTENT）* \
  @fig:task-state における[7]である．タスクが作成されていない，または，削除されている状態である．

上記のうち，待ち状態については，「[3]待ち状態(WAITING)」，「[4]二重待ち状態(WAITING-SUSPENDED)」，「[5]強制待ち状態(SUSPENDED)」に細分化される．

待ち状態は，自タスクを中断するサービスコールを呼び出したときに，実行状態から遷移する．待ち状態から復帰するときは，中断した箇所の後から再開する．一方，強制待ち状態は，他のタスクによって強制的に実行を中断させられた状態である．自タスクを強制待ち状態にすることもできる．また，二重待ち状態は，待ち状態のときに，他タスクから強制待ち状態に遷移させられた場合に遷移する．

また，μITRON4.0では，休止状態のタスクを実行可能状態にすることを「タスクの起動」と呼び，実行可能状態または実行状態のタスクを休止状態にすることを「タスクの終了」と呼ぶ．

=== スケジューリング
タスクのスケジューリングとは，複数のタスクが存在する場合に，どのタスクにCPUリソースを割り当てるかを決定することである．μITRON4.0では，優先度ベーススケジューリング方式を採用している．この方式では，各タスクに優先度が割り当てられており，実行可能状態にあるタスクの中で最も高い優先度を持つタスクが選択され，CPUリソースが割り当てられる． 優先度は数値で表され，数値が小さいほど高い優先度を示す．例えば，優先度1のタスク1と，優先度2のタスク2が実行可能状態にある場合，タスク1が選択される．TOPPERS/ASPカーネルでは，優先度の範囲は1から16までであり，1が最も高い優先度である#footnote[ただし，割込み処理の際にはマイナスの優先度が割り当てられることがある．]．

また，同じ優先度を持つ複数のタスクが実行可能状態にある場合には，FCFS(First Come First Served)方式が採用される．この方式では，最も早く実行可能状態になったタスクが選択される．例えば，優先度1のタスク1とタスク2が実行可能状態にあり，タスク1が先に実行可能状態になった場合，タスク1が選択される．

=== コンフィグレーション
TOPPERS/ASPカーネルでは，オブジェクトを静的生成する．ここでいうオブジェクトとは，タスクやセマフォなど，OSが抽象化や利便性のために生成するものの総称である．静的生成とは，OSの起動前にオブジェクトを生成すること，つまり，ビルド時に実行ファイルを含めることであり，動的生成とは，OSの起動後にオブジェクトを生成することである．

オブジェクトを動的生成する場合，資源が不足した場合に生成に失敗する可能性がある．また，資源の確保にかかる時間が特定できず，リアルタイム性を保証できない．そのため，TOPPERS/ASPカーネルでは，オブジェクトを静的生成することで，リアルタイム性を確保している．

本実験では，コンフィグレーションに関する記述を「＜appname＞.cfg」ファイルに記述する．このファイルでは，タスクやセマフォの生成情報や，割込みの設定を行う．ここで，コンフィグレータがcfgファイルから，kernel_cfg.c，kernel_cfg.hなどを生成する．

// == サービスコール
// == 開発環境について

// 本実験ではクロス開発を行う．クロス開発とは PC 上でコンパイルして実行は別のターゲットとする開発のことである．また，本実験では組込みシステム開発向けの統合開発環境(IDE)としてCS+(Renesas Electronics)を使用する．以下，プロジェクトの設定方法から，ビルド，デバッグ，ダウンロードまでの手順を，図を用いて説明する．