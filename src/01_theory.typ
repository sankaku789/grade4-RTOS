= 原理

#include "research.typ"

== 使用するRTOSとその要素技術

本実験では，@sec:rtos-types[]項にて示したTOPPERSプロジェクトの一つである，TOPPERS/ASP（TOPPERS/Advanced Standard Profile）カーネルを使用する．このカーネルはμITRON4.0仕様に準拠しており，割込み処理モデルの標準化や，コンフィグレーションの見直し，コンポーネント開発への対応などが行われている．μITRON4.0仕様#footnote[この規定は東京大学の坂村 健，及び，高田 広章らによって作成された．]とは，組込みシステム用リアルタイムOSとその仕様を定めた規定である．特徴として，多数の組込み用プロセッサに対応しており，自由に実装できるオープンな仕様であることが挙げられる．

次に，TOPPERS/ASP第2世代カーネルの主要な要素技術について説明する．

=== タスク

「タスク」(または，プロセス)は，プログラムの実行単位であり，オペレーティングシステムにおける基本概念である．1つのタスクは逐次実行され，異なるタスクのプログラムはスケジューリングによって並列実行される．タスクのうち，後述するサービスコール(SVC)を呼び出すタスクを「自タスク」という．

次に，タスクが実行される環境のことを「コンテキスト」と呼ぶ．コンテキストは，プロセッサの動作モード，レジスタ，スタック空間から構成される．また，コンテキストのうち，OSが管理し，スケジューラの想定しているタイミングで実行されるコンテキストは「タスクコンテキスト」という．ここで，タスクコンテキストは，スケジューラの想定しているタイミングで実行されるため，OSにとっては同期的と言える．一方，割込み処理ルーチンなどOSの想定外のタイミングで実行されるコンテキストは「非タスクコンテキスト」と呼ばれる．

#figure(
  image("fig/state.drawio.svg", width: 65%),
  caption: [タスクの状態遷移図]
)<fig:task-state>

次に，タスクの状態について説明する．TOPPERS/ASPカーネルでは，広義的に5つの状態が存在する．以下，箇条書きで示す．

- *実行状態(RUNNING)*
  - @fig:task-state における[1]である．CPUリソースを確保し，そのタスクがプログラムを実行中している状態であり，そのタスク(プログラム)を実行している状態である．

- *実行可能状態(REDAY)*
  - @fig:task-state における[2]である．CPUリソースを確保していないが，実行可能な状態であり，スケジューラによって選択されるのを待っている状態である．

- *待ち状態(WAITING)*
  - @fig:task-state における[3][4][5]である．イベントの発生や，リソースの解放などを待っている状態であり，その条件が満たされるまで実行できない状態である．

- *休止状態(SUSPENDED)*
  - @fig:task-state における[6]である．タスクがまだ起動されていない，言い換えると，実行可能状態になる前の状態である．

- *未登録状態(NON-EXISTENT)*
  - @fig:task-state における[7]である．タスクが作成されていない，または，削除されている状態である．

#v(5pt)

上記のうち，待ち状態については，「[3]待ち状態(WAITING)」，「[4]二重待ち状態(WAITING-SUSPENDED)」，「[5]強制待ち状態(SUSPENDED)」に細分化される．

待ち状態は，自タスクを中断するサービスコールを呼び出したときに，実行状態から遷移する．待ち状態から復帰するときは，中断した箇所の後から再開する．一方，強制待ち状態は，他のタスクによって強制的に実行を中断させられた状態である．自タスクを強制待ち状態にすることもできる．また，二重待ち状態は，待ち状態のときに，他タスクから強制待ち状態に遷移させられた場合に遷移する．

=== スケジューリング

=== コンフィグレーション

=== サービスコール

=== ハードウェアの抽象化


== 開発環境について

本実験ではクロス開発を行う．クロス開発とは PC 上でコンパイルして実行は別のターゲットとする開発のことである．また，本実験では組込みシステム開発向けの統合開発環境(IDE)としてCS+(Renesas Electronics)を使用する．以下，プロジェクトの設定方法から，ビルド，デバッグ，ダウンロードまでの手順を，図を用いて説明する．